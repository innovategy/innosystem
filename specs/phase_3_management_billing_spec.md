# Innovation Ecosystem Platform - Phase 3 Specification: Entity Management & Billing Integration\n\n## 1. Phase Goal\n\nBuild out APIs for managing Resellers, Customers, and Projects. Integrate job costing with the Wallet system more formally using transactions. Implement basic runner discovery and registration.\n\n## 2. Phase Deliverables\n\n*   Implement remaining data models (Reseller, Project, Runner, WalletTransaction) and their repositories/migrations.\n*   Create CRUD API endpoints for Resellers, Customers, and Projects (including API key generation/handling for Resellers & Customers).\n*   Implement wallet transaction logging (`WalletTransaction` model/repository).\n*   Refine job processing logic: calculate final `cost_cents` (potential for dynamic calculation stubbed), create corresponding wallet transactions upon job completion.\n*   Implement basic runner registration API endpoint and mechanism for the core system to track active runners (e.g., in Redis or DB).\n*   Implement logic in the job assignment process (or runner) to ensure jobs are only processed by compatible runners.\n*   **Functional Outcome:** Full CRUD for core entities (Reseller, Customer, Project) via API with basic authentication. Billing transactions are recorded per job. Runners register, and only process jobs they are compatible with.\n\n## 3. Technology Stack (Additions/Focus)\n\n*   **API Authentication:** Basic API Key checking (middleware).\n*   **Hashing (for API Keys):** `argon2` or similar (optional, could store keys plaintext initially).\n\n## 4. Data Models & Database Schema (Additions)\n\n*   **Migrations (`diesel_migrations`):\n    *   `resellers` table (id, name, email, api_key, active, commission_rate, created_at, updated_at).\n    *   `projects` table (id, customer_id, name, description, created_at, updated_at).\n    *   `runners` table (id, name, description, status [e.g., 'active', 'inactive'], compatible_job_types [text[] or jsonb], last_heartbeat [timestamp], created_at, updated_at).\n    *   `wallet_transactions` table (id, wallet_id, job_id [nullable], transaction_type [enum/text: 'charge', 'refund', 'credit'], amount_cents, description, created_at).\n    *   Add necessary foreign keys (e.g., `projects.customer_id`, `wallet_transactions.wallet_id`).\n    *   Modify `customers` table: add `reseller_id` (nullable FK), refine `api_key` handling.\n    *   Modify `jobs` table: add `project_id` (nullable FK).\n*   Define corresponding Diesel structs (`Reseller`, `Project`, `Runner`, `WalletTransaction`, `New...` variants).\n*   Update existing structs/tables as needed (e.g., add `project_id` to `Job`).\n\n## 5. Repository Layer (Additions)\n\n*   Define and implement traits for `ResellerRepository`, `ProjectRepository`, `RunnerRepository`, `WalletTransactionRepository`.\n*   `ResellerRepository`: CRUD operations, find by API key.\n*   `ProjectRepository`: CRUD operations, list by customer.\n*   `RunnerRepository`: `register` (create/update), `find_by_id`, `list_active`, `update_heartbeat`, `list_compatible(job_type_id)`.\n*   `WalletTransactionRepository`: `create`, `list_by_wallet`, `list_by_job`.\n*   Modify `WalletRepository`: `add_funds` (for credits), potentially update `deduct_balance` to create a transaction record.\n*   Modify `JobRepository`: Add methods to filter jobs by `project_id`.\n\n## 6. API Layer (Axum - New Endpoints & Auth)\n\n*   **Authentication Middleware:** Implement basic middleware to check for `X-API-Key` header and validate against `customers` or `resellers` tables.\n*   **Reseller Endpoints (`/resellers`):**\n    *   `POST /`: Create Reseller (Admin/Internal only initially?).\n    *   `GET /`: List Resellers (Admin/Internal).\n    *   `GET /:reseller_id`: Get Reseller details.\n    *   `PUT /:reseller_id`: Update Reseller.\n    *   `DELETE /:reseller_id`: Deactivate Reseller.\n*   **Customer Endpoints (`/customers`):**\n    *   `POST /`: Create Customer (potentially requires Reseller API key).\n    *   `GET /`: List Customers (requires Reseller or Admin key).\n    *   `GET /:customer_id`: Get Customer details (requires own key or Reseller/Admin).\n    *   `PUT /:customer_id`: Update Customer.\n    *   `POST /:customer_id/apikey`: Generate/Regenerate API key for Customer.\n*   **Project Endpoints (`/projects`):**\n    *   `POST /`: Create Project (requires Customer API key). Associate with Customer.\n    *   `GET /`: List Projects for the authenticated Customer.\n    *   `GET /:project_id`: Get Project details.\n    *   `PUT /:project_id`: Update Project.\n    *   `DELETE /:project_id`: Delete Project.\n*   **Runner Endpoints (`/runners`):**\n    *   `POST /register`: Runner registration/heartbeat. Expects runner info (name, capabilities). Creates or updates runner record, sets `last_heartbeat`.\n    *   `GET /`: List active runners (Admin/Internal).\n*   **Refine `POST /jobs`:**\n    *   Optionally accept `project_id`.\n    *   Perform authorization check (Customer owns the project, etc.).\n\n## 7. Runner Process (Refinements)\n\n*   **Registration/Heartbeat:** On startup and periodically (e.g., every 30-60s), call the `POST /runners/register` API endpoint with its ID (if known) and capabilities (`compatible_job_types`).\n*   **Compatibility Check:** Before processing a fetched job (`job_id`), the runner should re-fetch the `Job` details *and* its own configuration (`Runner` record) from the DB. Verify that the `job.job_type_id` is listed in its `runner.compatible_job_types`. If not compatible, log an error and potentially put the job back in the queue (or move to an error queue - TBD). *Alternatively, job assignment logic could pre-filter.* \n*   **Job Costing & Transaction:**\n    1.  After successful processing:\n    2.  **(Placeholder)** Calculate `final_cost_cents`. For Phase 3, this can still just be `job_type.standard_cost_cents`.\n    3.  Create a `NewWalletTransaction` record (type='charge', amount=final\_cost\_cents, job\_id=job.id, wallet\_id=wallet.id).\n    4.  Call `WalletTransactionRepository::create` to log the transaction.\n    5.  Call `WalletRepository::deduct_balance` (ensure this is atomic with transaction creation or idempotent).\n    6.  Update `Job` record with `status`, `completed_at`, and `cost_cents`.\n\n## 8. Runner Discovery/Tracking\n\n*   Implement a background task (either in the API process or a separate service) that periodically checks the `runners.last_heartbeat` timestamp. If a runner hasn't sent a heartbeat recently (e.g., > 2 minutes), mark its status as 'inactive' in the DB.\n*   The `RunnerRepository::list_active` method should filter based on this status and potentially the heartbeat timestamp.\n\n## 9. API Key Management\n\n*   When creating Customers/Resellers or regenerating keys, generate a secure random string.\n*   **(Optional):** Hash the key using Argon2 or similar before storing it in the DB. Store the hash, not the key. The middleware then hashes the provided key and compares hashes.\n*   **(Simpler):** Store the key directly in the DB for Phase 3. Emphasize this is temporary.\n
